// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth_sessions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuthSession = `-- name: CreateAuthSession :one
INSERT INTO auth_sessions (
    user_id,
    device_id_hash,
    access_token_hash,
    access_expires_at,
    refresh_token_hash,
    refresh_expires_at,
    created_at
)
VALUES ($1, $2, $3, $4, $5, $6, now())
RETURNING id, user_id, device_id_hash, access_token_hash, access_expires_at,
          refresh_token_hash, refresh_expires_at, rotated_at, revoked_at,
          last_used_at, created_at
`

type CreateAuthSessionParams struct {
	UserID           pgtype.UUID
	DeviceIDHash     []byte
	AccessTokenHash  []byte
	AccessExpiresAt  pgtype.Timestamptz
	RefreshTokenHash []byte
	RefreshExpiresAt pgtype.Timestamptz
}

func (q *Queries) CreateAuthSession(ctx context.Context, arg CreateAuthSessionParams) (AuthSession, error) {
	row := q.db.QueryRow(ctx, createAuthSession,
		arg.UserID,
		arg.DeviceIDHash,
		arg.AccessTokenHash,
		arg.AccessExpiresAt,
		arg.RefreshTokenHash,
		arg.RefreshExpiresAt,
	)
	var i AuthSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceIDHash,
		&i.AccessTokenHash,
		&i.AccessExpiresAt,
		&i.RefreshTokenHash,
		&i.RefreshExpiresAt,
		&i.RotatedAt,
		&i.RevokedAt,
		&i.LastUsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAuthSessionByAccessHash = `-- name: GetAuthSessionByAccessHash :one
SELECT id, user_id, device_id_hash, access_token_hash, access_expires_at,
       refresh_token_hash, refresh_expires_at, rotated_at, revoked_at,
       last_used_at, created_at
FROM auth_sessions
WHERE access_token_hash = $1
  AND access_expires_at > $2
  AND revoked_at IS NULL
`

type GetAuthSessionByAccessHashParams struct {
	AccessTokenHash []byte
	AccessExpiresAt pgtype.Timestamptz
}

func (q *Queries) GetAuthSessionByAccessHash(ctx context.Context, arg GetAuthSessionByAccessHashParams) (AuthSession, error) {
	row := q.db.QueryRow(ctx, getAuthSessionByAccessHash, arg.AccessTokenHash, arg.AccessExpiresAt)
	var i AuthSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceIDHash,
		&i.AccessTokenHash,
		&i.AccessExpiresAt,
		&i.RefreshTokenHash,
		&i.RefreshExpiresAt,
		&i.RotatedAt,
		&i.RevokedAt,
		&i.LastUsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAuthSessionByRefreshHash = `-- name: GetAuthSessionByRefreshHash :one
SELECT id, user_id, device_id_hash, access_token_hash, access_expires_at,
       refresh_token_hash, refresh_expires_at, rotated_at, revoked_at,
       last_used_at, created_at
FROM auth_sessions
WHERE refresh_token_hash = $1
  AND refresh_expires_at > $2
  AND revoked_at IS NULL
`

type GetAuthSessionByRefreshHashParams struct {
	RefreshTokenHash []byte
	RefreshExpiresAt pgtype.Timestamptz
}

func (q *Queries) GetAuthSessionByRefreshHash(ctx context.Context, arg GetAuthSessionByRefreshHashParams) (AuthSession, error) {
	row := q.db.QueryRow(ctx, getAuthSessionByRefreshHash, arg.RefreshTokenHash, arg.RefreshExpiresAt)
	var i AuthSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceIDHash,
		&i.AccessTokenHash,
		&i.AccessExpiresAt,
		&i.RefreshTokenHash,
		&i.RefreshExpiresAt,
		&i.RotatedAt,
		&i.RevokedAt,
		&i.LastUsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const markAuthSessionUsed = `-- name: MarkAuthSessionUsed :exec
UPDATE auth_sessions
SET last_used_at = $2
WHERE id = $1
`

type MarkAuthSessionUsedParams struct {
	ID         pgtype.UUID
	LastUsedAt pgtype.Timestamptz
}

func (q *Queries) MarkAuthSessionUsed(ctx context.Context, arg MarkAuthSessionUsedParams) error {
	_, err := q.db.Exec(ctx, markAuthSessionUsed, arg.ID, arg.LastUsedAt)
	return err
}

const revokeAuthSession = `-- name: RevokeAuthSession :exec
UPDATE auth_sessions
SET revoked_at = $2
WHERE id = $1
`

type RevokeAuthSessionParams struct {
	ID        pgtype.UUID
	RevokedAt pgtype.Timestamptz
}

func (q *Queries) RevokeAuthSession(ctx context.Context, arg RevokeAuthSessionParams) error {
	_, err := q.db.Exec(ctx, revokeAuthSession, arg.ID, arg.RevokedAt)
	return err
}

const rotateAuthSession = `-- name: RotateAuthSession :exec
UPDATE auth_sessions
SET rotated_at = $2
WHERE id = $1
  AND rotated_at IS NULL
  AND revoked_at IS NULL
`

type RotateAuthSessionParams struct {
	ID        pgtype.UUID
	RotatedAt pgtype.Timestamptz
}

func (q *Queries) RotateAuthSession(ctx context.Context, arg RotateAuthSessionParams) error {
	_, err := q.db.Exec(ctx, rotateAuthSession, arg.ID, arg.RotatedAt)
	return err
}
